<!DOCTYPE html>
<head>
<link rel="stylesheet" type="text/css" href="blogstyles.css"/>
<link href='https://fonts.googleapis.com/css?family=Rock+Salt' rel='stylesheet' type='text/css'>
<title>Blog</title>
</head>
<body>
	
	<div id="header">		
		<p id="title"><strong>
		<sp id="ns">n</sp>eophyte to k<sp id="ns">n</sp>owledgeable in 
		<sp id="ns">n</sp>ineteen weeks</strong>
		<sp id="subtitle"><br>Watch me learn how to program. It'll be fun.</sp></p>
	</div>
	
	<div class="left">
		<a href="http://sarahlobser.github.io/index.html">
		<img src="Sarah-laughingfuncolors.jpg"/></a>
		<h1 id="caption">It's Happening.</h1>
	</div>
	
	<div class="right">
		<ul>
			<li><h2>Intro</h2><h5>A first-time blogger blogs about learning how to 
				program, and hopefully learns how to blog in the process</h5>
				<p>Here I am at ground zero of my decision to take up web development 
				as a potential career. On February 29, 2016, I will begin a nineteen 
				week program designed to turn me into a full stack Java developer. 
				These "developer boot camps," as they're called, are really in these days.
				It seems universities can't churn out qualified CS degree holders fast
				enough to meet the industry's demand, and programs are popping up all 
				over hoping to fill in the training gap and take their slice of the 
				tech-$ cake. I chose 
				<a href = "http://www.skilldistillery.com">Skill Distillery</a> 
				for 3 reasons: 1. Skill Distillery 
				is the only program of its kind (at the time of this writing) to accept
				the GI Bill. As a veteran of the US Navy with a GI Bill burning a hole in 
				my pocket right now, this is a huge selling point. 2. Curriculum. Skill 
				Distillery's main priority is to help me get a job. Where a lot of other
				boot camps focus on Ruby, Java is a key component on most developer job
				announcements. I learned Java almost 20 years ago, and apparently it's 
				still a thing. 3. Geographical location. Skill Distillery happens to be
				right down the road from my home town of Littleton, Colorado. 
				Besides, who can argue with the 
				Rocky Mountains? No one can. Mountains are made of rocks, and rocks
				don't argue.</p><p>So join me on my journey as I attempt to get from
				neophyte to knowledgeable in nineteen weeks. 
				Witness my frustrations, excitement, 
				victories, and failures. What could be more fun?
				</p>
			</li>
			<li><h2>February 5, 2016: Day -24</h2>
				<h5>Pre-work! And,<br>
			    The difference between <sp>switch</sp> and 
			    <sp>if else</sp> in Java</h5>
			    <p>I'm in the midst of pre-work for the developer boot camp I'm starting 
			    in 24 days. I've been tasked with building a web presence via this blog. 
			    This is meant to showcase my growing technical knowledge, though I will 
			    also be using it to vent my frustrations, gloat over my breakthroughs 
			    (assuming these will occur), 
			    and muse over the process of learning in general.</p>
			    <p>I'm currently working through <a href="http://learnjavathehardway.org">
			    Learn Java The Hard Way</a>. This seems like a great text for beginners. 
			    Lots of practice writing workable code, lots of repetition. As I am not 
			    a complete beginner, there's a bit too much repetition and slow build-up
			    for my taste. So I do skip around a bit, and hope that's not just a 
			    manifestation of my lack of patience. As for technical details, I suppose 
			    it's time to throw you a tidbit...</p>
			    <h5>if else statements in Java. What are they all about?
			    </h5>
			    <p>
			    The basic construct goes like this:
			    <br><br><sp class="code">if (condition is true) {do this}</sp>
			    <br><br>else can be used in conjunction, as an "otherwise..." statement:
			    <br><br><sp class="code">if (condition is true) {do this}
			    <br>else {do that}</sp>
			    <br><br>multiple mutually exclusive conditions can be tested in a 
			    chain of if else statements:
			    <br><br><sp class="code">if (condition A is true) {do this}
			    <br>else if (condition B is true) {do this other thing}
			    <br>else if (condition C is true) {do that}
			    <br>else {do something else entirely}</sp>
			    </p>
			    <p>So if else is an all-purpose construct for testing conditions. Another 
			    way to test for conditions is the switch statement. Switch has a narrower 
			    range of applicability, but in certain circumstances is the best option. 
			    Consider the following pseudo-example:
			    <br><br><sp class="code">switch(variable with, say, 4 possible values) {
			    <br>case 1: do a thing; break;
			    <br>case 2: do another thing; break;
			    <br>case 3: do a third thing; break;
			    <br>case 4: do a fourth thing; break;
			    <br>}</sp>
			    <h5>switch: when do I use it?</h5> 
			    <p>
			    There are a couple things to consider.
			    Any switch statement could be written as an if-else statement,
			    but only certain if-else statements can be re-written using switch. Also, 
			    if-else can test over a range of values or conditions (is n less than 5?),
			    but switch tests for equality only and is used when the variable in 
			    question can take one of several (discrete) values. 
			    The example I have seen most often
			    is months of the year. The variable "month" can only take one of 12 values.
			    In this scenario using switch works better than if-else for two reasons. 
			    First, it's faster. switch is compiled to a lookup table and involves one 
			    operation. Written as an if-else statement, each case is tested, which
			    takes N operations (N being the number of cases). 
			    Second, it's cleaner and easier to read and maintain.
			    </p>
			</li>
			<li><h2>February 12, 2016: Day -17</h2>
				<h5>Java the Hard Way next steps, and working with arrays</h5>
				<p>Over the past week I have skipped around through the Java the Hard
				Way book, going through exercises I found interesting. At the very end
				of the book, Graham Mitchell gives us a nice pat on the back for 
				finishing these 58 exercises, then tells us we still need a lot more
				practice. And it's true! He gives a link to a series of assignments he 
				gives to his students: </p>
				<p><a href = "https://programmingbydoing.com/">
				programmingbydoing.com</a></p><p>
				I like these exercises because I don't get to cheat by looking at the 
				code already written in front of me and typing it out word for word.
				That puts me in a trance-like state and I have a hard time really learning
				the material. These "next step" exercises force me to rely on my memory 
				and work through a little trial and error before I figure things out.</p>
				<p>So for example, in the middle of the section on arrays, Mitchell 
				challenges us to create an array of 10 random numbers between 1 and 50.
				Then we ask the user for a number between 1 and 50 and tell them whether
				or that number is in the array. Here is the code I came up with: <br><br>
				<sp class = "code">
import java.util.Scanner;<br><br>

public class FindaValue {<br>
	public static void main(String[] args) {<br>
		int[] arr = new int[10];<br>
		int i = 0;<br>
		for(i = 0; i < arr.length; i++) {<br>
		   arr[i] = (int)(50*Math.random() + 1);<br>
		}<br><br>
		
		Scanner keyboard = new Scanner(System.in);<br>
		System.out.print("What number between 1 and 50 are you looking for? ");<br>
		int guess = keyboard.nextInt();<br><br>
		
		for(i = 0; i < arr.length; i++) {<br>
		   if(guess == arr[i]) System.out.println(guess + " is in the array!");<br>
		}<br>
	}<br>
}
				</sp><br><br>
				If the style of this code is lacking in indentation, it's because 
				I'm still a very new beginner with html and css, and haven't yet 
				figured out the best way to insert whitespace. Just use your 
				imagination for now.</p>
				<h5>Java Arrays</h5>
				<p>
				Java is a little awkward in my opinion. One of the more awkward things 
				I do in Java is initializing an array. "int[] arr = new int[10]" seems
				like it has a couple redundancies, but that's Java. There are three 
				steps in initializing an array. First you declare it (int[] arr), 
				and in this case I'm creating an integer array. This is important. 
				You can't just throw a double into an integer array and hope that the
				array will convert to an int for you. Your types have 
				to match. The second step is to 
				allocate space for the items you want to hold (new int[10]).
				This second step is also important. In Java, you can't 
				change the size of your
				array. If you say you want 10 integers, you will never be able to add 
				an 11th integer to that array. You would have to create a larger array 
				and copy everything from the old to the new array. Anyway, the third 
				step is to initialize the values held in the array. There is more 
				than one way to do this, but in the code here, I use a for loop with 
				a random number generator.</p>
				<p>Notice in the for loop where I use i < arr.length as my condition, 
				even though I know there are 10 items in the array, and 10 is a lot 
				shorter to write than arr.length. I do it this way because it's more 
				robust. Say I want to use this code again, but make the array bigger. 
				I won't have to scan through the code to see if I need to change a 
				bunch of 10s to, say, 50s. No matter what the size of the array happens 
				to be, the loop will go through the whole thing.</p>
				<p>Hope everyone has a great weekend. Happy Birthday, Lincoln!</p>
			</li>
			<li><h2>February 17, 2016: Day -12</h2>
				<h5>OOP, I did it again</h5>
				<p>Sorry, bad joke. I'm turning into my dad. OOP of course stands for
				<sp class="emph">O</sp>bject <sp class = "emph">O</sp>riented 
				<sp class="emph">P</sp>rogramming. If you've been programming in Java,
				you've been using an object oriented language. I've been working through 
				these beginners books, writing code in Java, using this object oriented 
				programming language, without really digging in to the object-oriented 
				features of the language. 
				OOP is a defining feature of the language, but it 
				usually takes quite a while for the beginner to get a full explanation 
				of what OOP means and how to make use of it.</p>
				<p>The concepts in OOP are really pretty natural. 
				Look around you and you'll see all kinds of objects belonging to 
				different classes. Your chair, your dog, your house, etc. 
				If you check out 
				<a href="https://docs.oracle.com/javase/tutorial/java/concepts/">
				Oracle's OOP tutorial<a> you'll see how they describe the features of 
				classes and objects using the example of bicycles.</p>
				<p>But let's compare a couple classes we see often as beginners.
				The String class and the Math class. If you open up the documentation, 
				you can see that the String class has constructors, and the Math class 
				does not. It makes sense, we're always making new String
				objects to use, but 
				we can't really make a new Math object, can we?</p>
				<p>This brings us to instance vs. static methods. In a class like 
				String, you can see both instance and static methods. An instance method 
				is always called from an instance of a class, that is, an object.</p>
				<p>Let's make a new String:<br><br>
				<sp class="code">String s = "sarah";</sp><br><br>
				And now let's find out where the h is in the String:<br><br>
				<sp class="code">s.indexOf("h");</sp><br><br>
				The indexOf() method is an instance method, so I call it from the 
				object in question, which in this case is s. The syntax is 
				object.method(arguments).
				<p>What about static methods? You can see an example of a static 
				method in my last blog entry, where I used a random number generator:
				<br><br>
				<sp class="code">Math.random();</sp>
				<br><br>
				A static method doesn't get called from a particular object, that 
				wouldn't make sense. Instead the syntax is 
				Class.staticMethod(arguments). This syntax only changes when you're 
				calling the method from inside the class, in which case you can drop 
				the class and just use staticMethod(arguments).</p>
				<p>I hope that makes sense. OOP is a big topic, and I don't want to 
				totally delve into it with one blog entry. Little by little might be 
				better.</p>
				<p>On a different note, let me share with you another learning tool I've 
				been using of late. It's a book called 
				<a href="https://www.crcpress.com/A-Concise-Introduction-to-Data-Structures-using-Java/Johnson/9781466589896">
				"A Concise Introduction to Data 
				Structures Using Java"</a> by 
				<a href="https://www.crcpress.com/authors/i239-mark-j-johnson">
				Mark J. Johnson</a>. 
				It is, as the title implies, quite concise. It's also clear and easy to 
				read. For a beginner who has been through Learn Java the Hard Way and is 
				interested in data structures, I highly recommend this book. 
				Sometimes I'm sure hardcopy books are going by the wayside, but I keep 
				finding scenarios in which being able to flip through the pages of a book 
				is preferable to working through a digital document.</p>
				<p>
				<li>
				<h2>February 22, 2016: Day -7</h2>
				<h5>A Java stack interface and array implementation</h5>
				<p>
				I'm working through this book I mentioned in my last post, A Concise 
				Introduction to Data Structures Using Java. After getting through the 
				front material, and a chapter on algorithm analysis (super interesting), 
				I finally arrived at the discussion of the first data structure. Stacks. 
				</p>
				<p>
				A stack can be described conceptually pretty easily because we see 
				stacks of actual objects all the time. A stack of books. A stack of 
				pancakes. A stack of towels. Whatever. The whole idea is you put items 
				onto a stack one after another, and when you take something off the 
				stack it comes off in the reverse order. And to be syntactically correct,
				we'd say we'd "push" an item to the stack and
				 "pop" the item to get it out. This is a <sp class="emph">LIFO</sp> 
				 process. That is, Last In First Out.
				 </p>
				 <p>
				 Now if we want to use a stack in one of our projects, we have to 
				 <sp class="emph">implement</sp> the abstract concept of the stack, 
				 and just like there is more than one way to skin a cat (I don't know 
				 who ever came up with this expression, and I don't know why you'd 
				 ever want to skin a cat, and maybe I just don't get it and maybe 
				 I shouldn't use an expression that I don't fundamentally understand) 
				 there is more than one way to implement a stack.
				 </p>
				 <p>
				 Before I get into the specifics of the implementation, I want to talk 
				 about 
				 <sp class="emph">interfaces</sp>. 
				 This is a concept I'm just starting to wrap my 
				 head around. And it's strange to think about wrapping my head around 
				 something, because I start to imagine my head is a sweater, or a 
				 blanket, and I'm pulling the edges around some outside object and 
				 zipping it up or something. That's just weird.
				 </p>
				 <p>
				 Interfaces are also a little weird to me, but I'm starting to see 
				 how they can be very useful. An interface is like the skeleton of 
				 a class, with just a list of methods and no details on how those 
				 methods will be implemented. For example, we want to use a stack, 
				 and we don't necessarily want to make decisions written in stone 
				 about how the stack should be implemented. We want to keep the details 
				 of the stack abstract. Here's a stack interface we can use:
				 </p>
				 <p><sp class="code">
				 public interface IntStack {<br>
   				 boolean isEmpty();<br>
  				 int peek();<br>
			     int pop();<br>
   				 void push(int item);<br>
   				 int size();<br>
				 }
				 </sp>
				 </p>
				 <p>
				 You'll notice the key word "interface" in the first line, where "class" 
				 would go if we were writing a class. Then it gives the signature 
				 for all the methods we want to use in our stack. We see push and pop.
				 There is also isEmpty() which returns a boolean (true/false) telling 
				 you whether the stack is empty. There's peek() which returns the top 
				 value of the stack without popping that item. And there's size(), which,
			     of course, will tell you the size of the stack. If you want, you can 
			     think of an interface as a coded version of an API.
				 </p>
				 <p>
				 So now that we have an interface, we have to do something to make the 
				 methods presented here functional. Well that something is called an 
				 implementation. And there is a specific way we write an implementation 
				 in Java. An implementation is really just another class like we're 
				 used to, with two caveats. First, in the definition of the class we
				 have to add code that links the class to the interface. And second, 
				 we have to make sure we include every method from the interface in the 
				 implementation class.
				 </p>
				 <p><sp class="code">
				 import java.util.EmptyStackException;<br><br>

public class IntArrayStack implements IntStack {<br>
   private int top = -1;<br>
   private int[] data;<br>
   private static final int DEFAULT_CAPACITY = 10;<br><br>
   
   public IntArrayStack() {<br>
      data = new int[DEFAULT_CAPACITY];<br>
   }<br><br>
   
   public void push(int item) {<br>
      if(top == data.length -1) resize(2 * data.length);<br>
      data[++top] = item;<br>
   }<br><br>
   
   public int pop() {<br>
      if(isEmpty()) throw new EmptyStackException();<br>
      return data[top--];<br>
   }<br><br>
   
   private void resize(int newCapacity) {<br>
      int[] newData = new int[newCapacity];<br>
      for(int i = 0; i <= top; i++) {<br>
         newData[i] = data[i];<br>
      }<br>
      data = newData;<br>
   }<br><br>
   
   public boolean isEmpty() {<br>
      if(top == -1) return true;<br>
      return false;<br>
   }<br><br>
   
   public int peek() {<br>
      if(isEmpty()) throw new EmptyStackException();<br>
      return data[0];<br>
   }<br><br>
   
   public int size() {<br>
      return data.length;<br>
   }<br><br>
   
   public static void main(String[] args) {<br>
      IntStack s = new IntArrayStack();<br>
      System.out.println("Empty? " + s.isEmpty());<br>
      System.out.println("Size? " + s.size());<br>
      for(int i = 0; i < 100; i++) {<br>
         s.push(i);<br>
      }<br>
      System.out.println("Empty? " + s.isEmpty());<br>
      System.out.println("Size? " + s.size());<br>
      for(int i = 0; i < 100; i++) {<br>
         System.out.print(" " + s.pop() + " ");<br>
      }<br>
   }<br>
}
				 </sp></p>
				 <p>
				 On the class definition line, you can see "public class IntArrayStack 
				 implements IntStack." This is what links this class to the interface 
				 IntStack. And if you compare one for one, you can see every method 
				 in the interface is included in this class.
				 </p>
				 <p>
				 So what's the upshot here? How do we use these things together to make 
				 a stack and do all the things we want to do with it? Well if you look 
				 at the main method here, you can get a better idea of how it all plays 
				 out. When we want a new stack, we create one using the interface syntax, 
				 along with the constructor from the implementation, as in:
				 </p>
				 <p><sp class="code">IntStack s = new IntArrayStack();</sp></p>
				 <p>
				 Here, s is a stack of type IntStack that utilizes the implementation 
				 IntArrayStack.
				 Now let's say we come along at a later date and decide we want to use 
				 a different implementation of the stack. 
				 Say we want to use a linked list implementation instead 
				 of an array implementation. Then we just change the 
				 constructor to something like 
				 <p><sp class="code">IntStack s = new IntLinkedStack();<sp></p>
				 <p>
				 and all the other code referencing the stack s can stay just the 
				 way it is.
				 </p>
				 <p>
				 I really haven't discussed the actual array implementation at all here. 
				 There are few items of interest there, and I'll just touch on those 
				 briefly.
				 </p>
				 <p>
				 The first item of interest is the resize method. One thing that 
				 frustrates me about Java is that arrays cannot be resized. Once you 
				 define an array, you can't make it bigger or smaller to suit your needs.
				 Maybe I've talked about this before, that's how much it frustrates me. 
				 Anyway, in a stack implementation, you may not know how big of an array 
				 you need to begin with, so you have to guess. Then when you fill up the 
				 array you have to create an new, bigger array and copy everything from 
				 the old one to the new one. Well to be efficient about it, it's better 
				 to just double the size of the array each time you need a bigger one, 
				 rather than adding entries one at a time. This effectively adds a 
				 logarithmic growth function instead of a linear one, so quite a bit 
				 faster.
				 </p>
				 <p>
				 Another item of interest is the prefix vs. postfix increments and 
				 decrements in the push and pop methods. data[++top] does two things. 
				 First it increments top by one. Then it references the item in data 
				 with the incremented index. data[top--] also does two things. First 
				 it references the item in data with the index top. Then it decrements 
				 top. Just by placing the ++ and -- either before or after the variable 
				 here changes the order of the operation. I think that's neat.
				 </p>
				 <p>
				 The third item of interest is the Exception throwing. I haven't talked 
				 about Exceptions at all yet I don't think. They're really important, 
				 and I don't totally understand how to use them. I know there are 
				 many different classes of Exceptions and can be used to let the user 
				 know what kind of error was encountered at runtime. When one is thrown it 
				 immediately stops running the code, and "catch" blocks come into play 
				 as well. Not sure exactly how to use catch blocks. Exceptions are on 
				 my list of things I should someday write about here. Stay tuned.
				 </p>
				</li>
				
		</ul>
	</div>
	
</body>
</html>